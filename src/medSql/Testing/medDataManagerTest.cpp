// /////////////////////////////////////////////////////////////////
// Generated by dtkTestGenerator
// /////////////////////////////////////////////////////////////////

#include "medDataManagerTest.h"

#include <medDataManager.h>

#include <dtkCore/dtkAbstractDataFactory.h>
#include <medDbControllerFactory.h>
#include <medMetaDataKeys.h>
#include <medDatabaseController.h>
#include <medDatabaseNonPersistentController.h>
#include <medStorage.h>

#include <medTest/medQtDataImage.h>
#include <medTest/medQtDataImageReader.h>
#include <medTest/medQtDataImageWriter.h>

#include <QtTest/QSignalSpy>



medDataManagerTestObject::medDataManagerTestObject(void)
{
    m_storagePath =  QCoreApplication::applicationDirPath() + "/testSqlTempDb";
    m_currentId = 0;
    
    connect(this, SIGNAL(dataAdded()), &m_eventLoop, SLOT(quit()));
}

medDataManagerTestObject::~medDataManagerTestObject(void)
{

}

void medDataManagerTestObject::initTestCase(void)
{
    qRegisterMetaType<medDataIndex>();
    
    QVERIFY( medQtDataImage::registered() );
    QVERIFY( medQtDataImageReader::registered() );
    QVERIFY( medQtDataImageWriter::registered() );
 
    medStorage::rmpath(m_storagePath);
    medStorage::setDataLocation( m_storagePath );
    
    QVERIFY( medDatabaseController::instance()->createConnection() );
    
    //Register dbController
    medDbControllerFactory::instance()->registerDbController("DbController", createDbController);
    medDbControllerFactory::instance()->registerDbController("NonPersistentDbController", createNonPersistentDbController);
    
    const int persistentSourceId = 1;
    const int nonPersistentSourceId = 2;

    db = medDataManager::instance()->controllerForDataSource(persistentSourceId);
    QVERIFY( db );
    
    npDb = medDataManager::instance()->controllerForDataSource(nonPersistentSourceId);
    QVERIFY( npDb );  
    
    connect(medDataManager::instance(), SIGNAL(dataAdded(const medDataIndex&)), this, SLOT(onDataAdded(const medDataIndex&)));
    connect(medDataManager::instance(), SIGNAL(dataRemoved(medDataIndex)), this, SLOT(onDataRemoved(const medDataIndex&)));

}

void medDataManagerTestObject::init(void)
{

}

void medDataManagerTestObject::cleanup(void)
{
   // removeDir(m_storagePath);
}

void medDataManagerTestObject::cleanupTestCase(void)
{
   removeDir(m_storagePath);   
}

dtkSmartPointer<dtkAbstractData> medDataManagerTestObject::createTestData(void)
{
    // Create a data.
    dtkAbstractDataFactory *dataFactory = dtkAbstractDataFactory::instance();
    dtkSmartPointer<dtkAbstractData> testData = dataFactory->createSmartPointer(medQtDataImage::s_description());
    
    QString sDatetime = QDateTime::currentDateTime().toString("hms");

    medMetaDataKeys::PatientName.set(testData,"TestPatient" + QString::number(m_currentId));
    medMetaDataKeys::StudyDescription.set(testData,"TestStudy" + QString::number(m_currentId));
    medMetaDataKeys::SeriesDescription.set(testData,"TestSeries" + QString::number(m_currentId));
    medMetaDataKeys::BirthDate.set(testData, sDatetime);
    m_currentId++;

    QImage testImage(QSize( 800, 500 ), QImage::Format_Mono );

    QPainter painter(&testImage);
    painter.setRenderHints(QPainter::Antialiasing);
    painter.setPen(Qt::gray);
    painter.fillRect(testImage.rect(), Qt::black);

    painter.drawEllipse(QPoint(400,250), 300, 100);

    testData->setData( &testImage );
    return testData;
}


void medDataManagerTestObject::testImport(void)
{
    m_currentData = createTestData();

    medDataManager::instance()->import(m_currentData);

    waitForInsertions();
   
    IndexList patients = db->patients();
    QCOMPARE(patients.size(), 1);
    IndexList studies = db->studies(patients[0]);
    QCOMPARE(studies.size(), 1);
    IndexList series = db->series(studies[0]);
    QCOMPARE(series.size(), 1);
    
    QCOMPARE( npDb->patients().size(), 0 );

    const medDataIndex importedIndex = series[0];
    QVERIFY(importedIndex.isValid());

    // Check data in db matches original.
    compareData();
}

void medDataManagerTestObject::testImportNonPersistent(void)
{
    m_currentData = createTestData();
    
    IndexList prevNPPatients = npDb->patients();
    
    medDataManager::instance()->importNonPersistent(m_currentData);
    
    waitForInsertions();
    
    IndexList patients = npDb->patients();
    QCOMPARE(patients.size(), prevNPPatients.size()+1);
    IndexList studies = npDb->studies(m_lastInsertedIndex);
    QCOMPARE(studies.size(), 1);
    IndexList series = npDb->series(m_lastInsertedIndex);
    QCOMPARE(series.size(), 1);

    const medDataIndex importedIndex = series[0];
    QVERIFY(importedIndex.isValid());
    QVERIFY(m_lastInsertedIndex.isValid());

    compareData();
}

void medDataManagerTestObject::testImport2NonPersistentSeries(void)
{
    // import a first serie
    testImportNonPersistent();
    
    IndexList prevNPPatients = npDb->patients();
    
    //and import a second serie, copied from the first one just changing series description
    
    //going back by one to dupplicate the data
    m_currentId--;
    m_currentData = createTestData();
    medMetaDataKeys::SeriesDescription.set(m_currentData,"TestSeries" + QString::number(m_currentId-1) + "bis");
    
    medDataManager::instance()->importNonPersistent(m_currentData);
    
    waitForInsertions();
    
    IndexList patients = npDb->patients();
    //patients size should be the same
    QCOMPARE(patients.size(), prevNPPatients.size());
    IndexList studies = npDb->studies(m_lastInsertedIndex);
    //studies size should be the same
    QCOMPARE(studies.size(), 1);
    IndexList series = npDb->series(studies[0]);
    //but there should be 2 series
    QCOMPARE(series.size(), 2);

    compareData();   
}

void medDataManagerTestObject::testImportFile(void)
{    
    //create a file to be imported 
    medQtDataImageWriter writer;
    m_currentData = createTestData();
    writer.setData(m_currentData);
    m_fileToImport = m_storagePath + "/fileToImport.png";
    QVERIFY( writer.write(m_fileToImport) == true );
    
    IndexList currentPatients = db->patients();

    medDataManager::instance()->import(m_fileToImport, false);
    
    waitForInsertions();
  
    IndexList patients = db->patients();
    QCOMPARE(patients.size(), currentPatients.size()+1);
    IndexList studies = db->studies(patients[patients.size()-1]);
    QCOMPARE(studies.size(), 1);
    IndexList series = db->series(studies[studies.size()-1]);
    QCOMPARE(series.size(), 1);

    const medDataIndex importedIndex = series[0];
    QVERIFY(importedIndex.isValid());

    // Check data in db matches original.
    compareData();
    
}

void medDataManagerTestObject::testIndexFile(void)
{
    //create a file to be indexed 
    medQtDataImageWriter writer;
    m_currentData = createTestData();
    writer.setData(m_currentData);
    m_fileToImport = m_storagePath + "/fileToIndex.png";
    QVERIFY(  writer.write(m_fileToImport) == true );
    
    IndexList currentPatients = db->patients();
    
    medDataManager::instance()->import(m_fileToImport, true);
    
    waitForInsertions();
   
    IndexList patients = db->patients();
    QCOMPARE(patients.size(), currentPatients.size()+1);
    IndexList studies = db->studies(patients[patients.size()-1]);
    QCOMPARE(studies.size(), 1);
    IndexList series = db->series(studies[studies.size()-1]);
    QCOMPARE(series.size(), 1);

    const medDataIndex importedIndex = series[0];
    QVERIFY(importedIndex.isValid());

    // Check data in db matches original.
    compareData();
    
}

void medDataManagerTestObject::testImportNonPersistentFile(void)
{
    //create a file to be indexed 
    medQtDataImageWriter writer;
    m_currentData = createTestData();
    writer.setData(m_currentData);
    m_fileToImport = m_storagePath + "/fileToImportInNPDb.png";
    QVERIFY(  writer.write(m_fileToImport) == true );
    
    IndexList currentPatients = npDb->patients();
    
    medDataManager::instance()->importNonPersistent(m_fileToImport);
    
    waitForInsertions();
   
    IndexList patients = npDb->patients();
    QCOMPARE(patients.size(), currentPatients.size()+1);
    IndexList studies = npDb->studies(patients[patients.size()-1]);
    QCOMPARE(studies.size(), 1);
    IndexList series = npDb->series(studies[studies.size()-1]);
    QCOMPARE(series.size(), 1);

    const medDataIndex importedIndex = series[0];
    QVERIFY(importedIndex.isValid());

    // Check data in db matches original.
    compareData();    
}

void medDataManagerTestObject::testClearNonPersistentData(void)
{
    IndexList prevNPPatients = npDb->patients();
    
    if( prevNPPatients.size() == 0)
    {
        testImportNonPersistent();
        testImportNonPersistentFile();   
    }
    
    prevNPPatients = npDb->patients();
    
    QVERIFY( prevNPPatients.size() > 0 );
    
    medDataManager::instance()->clearNonPersistentData();
    
    IndexList patients = npDb->patients();
    
    QCOMPARE( patients.size(), 0 );
    QCOMPARE( medDataManager::instance()->nonPersistentDataCount(), 0 );
       
    //TODO: to complete   ?
     
}

void medDataManagerTestObject::testStoreNonPersistentDataToDatabase (void)
{
    /*
    IndexList prevNPPatients = npDb->patients();
    
    if( prevNPPatients.size() == 0)
    {
        testImportNonPersistent();
        testImportNonPersistentFile();   
    }
    
    IndexList prevPatients = db->patients();
    prevNPPatients = npDb->patients();
    
    QVERIFY( prevNPPatients.size() > 0 );
    
    medDataManager::instance()->storeNonPersistentDataToDatabase();

    waitForInsertions(prevNPPatients.size());
    
    IndexList currentPatients = db->patients();
    IndexList currentNPPatients = npDb->patients();
    
    QCOMPARE( currentPatients.size(), prevPatients.size() + prevNPPatients.size());
    QCOMPARE( currentNPPatients.size(), 0);
    
    //QCOMPARE( medDataManager::instance()->nonPersistentDataCount(), 0);
    
    //TODO: to complete  
    */
}




void medDataManagerTestObject::testStoreNonPersistentMultipleDataToDatabase(void)
{  
    IndexList prevNPPatients = npDb->patients();
    medDataIndex indexFor1Serie;
    medDataIndex indexFor2Series;
     
    if( prevNPPatients.size() == 0)
    {
        testImportNonPersistent();
        indexFor1Serie = m_lastInsertedIndex;
        testImport2NonPersistentSeries();   
        indexFor2Series = m_lastInsertedIndex;
    }
    
    IndexList prevPatients = db->patients();
    prevNPPatients = npDb->patients();
    
    QVERIFY( prevNPPatients.size() > 1 );
    
    // Test 1 - store just a serie
    
    // retrieve indexes for patient, study,serie 
    medDataIndex patient1;
    patient1.setDataSourceId(indexFor1Serie.dataSourceId());
    patient1.setPatientId(indexFor1Serie.patientId());
    medDataIndex study1 = npDb->studies(patient1)[0];
    medDataIndex serie1 = npDb->series(study1)[0];
    
    QCOMPARE(serie1, indexFor1Serie);
    
    dtkSmartPointer<dtkAbstractData> originalData = medDataManager::instance()->data( serie1 );
    
    medDataManager::instance()->storeNonPersistentMultipleDataToDatabase(serie1);
    
    waitForInsertions();
    
    QVERIFY( m_lastInsertedIndex.isValidForSeries());
    dtkSmartPointer<dtkAbstractData> insertedData = medDataManager::instance()->data( m_lastInsertedIndex );
    
    compareData(originalData, insertedData);
    
    // Test 2 - store a patient and its associated series
    
    // retrieve indexes for patient, study, serie 
    medDataIndex patient2;
    patient2.setDataSourceId(indexFor2Series.dataSourceId());
    patient2.setPatientId(indexFor2Series.patientId());
    medDataIndex study2 = npDb->studies(patient2)[0];
    IndexList series2 =  npDb->series(study2);
    QVERIFY( series2.size()>1 );
    medDataIndex serie2_1 = npDb->series(study2)[0];
    medDataIndex serie2_2 = npDb->series(study2)[1];
   
    dtkSmartPointer<dtkAbstractData> originalDataSerie2_1 = medDataManager::instance()->data( serie2_1 );
    dtkSmartPointer<dtkAbstractData> originalDataSerie2_2 = medDataManager::instance()->data( serie2_2 );
    
    medDataManager::instance()->storeNonPersistentMultipleDataToDatabase(patient2);
    
    waitForInsertions(series2.size());
    
    QVERIFY( m_insertedIndexes.size() > 1);
    
    dtkSmartPointer<dtkAbstractData> insertedDataSerie2_1 = medDataManager::instance()->data( m_insertedIndexes[0] );
    dtkSmartPointer<dtkAbstractData> insertedDataSerie2_2 = medDataManager::instance()->data( m_insertedIndexes[1] );
    
    // we don't know the order of insertion
    if( medMetaDataKeys::SeriesDescription.getFirstValue(insertedDataSerie2_1) ==  
        medMetaDataKeys::SeriesDescription.getFirstValue(originalDataSerie2_1))
    {
        compareData(insertedDataSerie2_1, originalDataSerie2_1);
        compareData(insertedDataSerie2_2, originalDataSerie2_2);
    }
    else if( medMetaDataKeys::SeriesDescription.getFirstValue(insertedDataSerie2_1) ==  
        medMetaDataKeys::SeriesDescription.getFirstValue(originalDataSerie2_2))
    {
        compareData(insertedDataSerie2_1, originalDataSerie2_2);
        compareData(insertedDataSerie2_2, originalDataSerie2_1);
    }
    else QVERIFY( false );
}

void medDataManagerTestObject::testStoreNonPersistentSingleDataToDatabase(void)
{
   /* IndexList prevNPPatients = npDb->patients();
    
    if( prevNPPatients.size() == 0)
    {
        testImportNonPersistent();
        testImportNonPersistentFile();   
    }
    
    IndexList prevPatients = db->patients();
    prevNPPatients = npDb->patients();
    
    QVERIFY( prevNPPatients.size() > 1 );
    
    medDataIndex patient1 = npDb->patients()[0];
    medDataIndex study1 = npDb->studies(patient1)[0];
    medDataIndex serie1 = npDb->series(study1)[0];
    medDataIndex patient2 = npDb->patients()[1];
    
    //store just a serie
    medDataManager::instance()->storeNonPersistentSingleDataToDatabase(serie1);
    m_timer.start(5000);
    m_eventLoop.exec();
    
    //store just a study
    medDataManager::instance()->storeNonPersistentSingleDataToDatabase(study1);
    m_eventLoop.exec();
    
    //store just a patient
    medDataManager::instance()->storeNonPersistentSingleDataToDatabase(patient1);
    m_eventLoop.exec();
    
    //store patient + study + serie
    medDataManager::instance()->storeNonPersistentSingleDataToDatabase(patient2);
    m_timer.start(5000);
    m_eventLoop.exec();*/
       
}

void medDataManagerTestObject::testNonPersistentDataCount(void)
{

}



void medDataManagerTestObject::testRemoveData(void)
{
    IndexList prevPatients = db->patients();
    IndexList prevNPPatients = npDb->patients();
    
    if(prevPatients.size()==0)
        testImport();
    if(prevNPPatients.size()==0)
        testImport2NonPersistentSeries();
    
    prevPatients = db->patients();
    prevNPPatients = npDb->patients();
    
    connect(this, SIGNAL(dataRemoved()), &m_eventLoop, SLOT(quit()));
    
    // test 1 - remove persistent patient
    medDataIndex study = db->studies(prevPatients[0])[0];
    medDataIndex serie = db->series(study)[0];
    
    medDataManager::instance()->removeData(prevPatients[0]);
    waitForDeletions();
    IndexList patients = db->patients();
    QCOMPARE( patients.size(), prevPatients.size()-1 );
    dtkSmartPointer<dtkAbstractData> data = medDataManager::instance()->data( prevPatients[0]);
    QVERIFY(!data);
    data = medDataManager::instance()->data( study );
    QVERIFY(!data);
    data = medDataManager::instance()->data( serie );
    QVERIFY(!data);
    
    
    // test 2 - remove non persistent patient
    medDataIndex npStudy = npDb->studies(prevNPPatients[0])[0];
    medDataIndex npSerie = npDb->series(npStudy)[0];
    
    medDataManager::instance()->removeData(prevNPPatients[0]);    
    waitForDeletions();
    IndexList npPatients = npDb->patients();
    QCOMPARE( npPatients.size(), prevNPPatients.size()-1 );
    data = medDataManager::instance()->data( prevNPPatients[0]);
    QVERIFY(!data);
    data = medDataManager::instance()->data( npStudy );
    QVERIFY(!data);
    data = medDataManager::instance()->data( npSerie );
    QVERIFY(!data);
    //TODO: add verification
}

void medDataManagerTestObject::testMoveStudy(void)
{
    
}

void medDataManagerTestObject::testMoveSerie(void)
{
    
}
   
   
void medDataManagerTestObject::onDataAdded(const medDataIndex& index)
{ 
    if(index.isValidForSeries())
    {
        m_lastInsertedIndex = index;
        qDebug() << "A serie has been inserted.";
        emit dataAdded();
    }
    else qDebug() << "PATIENT OR STUDY ADDED";
}

void medDataManagerTestObject::onDataRemoved(const medDataIndex& index)
{ 
    if(index.isValidForSeries())
    {
        qDebug() << "A serie has been removed.";
    }
    else qDebug() << "PATIENT OR STUDY REMOVED";
    
    emit dataRemoved();
}

bool medDataManagerTestObject::removeDir(const QString & dirName)
{
    bool result;
    QDir dir(dirName);

    if (dir.exists(dirName)) {
        Q_FOREACH(QFileInfo info, dir.entryInfoList(QDir::NoDotAndDotDot | QDir::System | QDir::Hidden  | QDir::AllDirs | QDir::Files, QDir::DirsFirst)) {
            if (info.isDir()) {
                result = removeDir(info.absoluteFilePath());
            }
            else {
                result = QFile::remove(info.absoluteFilePath());
            }

            if (!result) {
                return result;
            }
        }
        result = dir.rmdir(dirName);
    }
    return result;
}

void medDataManagerTestObject::compareData()
{
    // Check data in db matches original.
    dtkSmartPointer<dtkAbstractData> insertedData = medDataManager::instance()->data( m_lastInsertedIndex );
    QCOMPARE(insertedData->identifier(), m_currentData->identifier());
    QCOMPARE(medMetaDataKeys::PatientName.getFirstValue(insertedData),
        medMetaDataKeys::PatientName.getFirstValue(m_currentData));
    QCOMPARE(medMetaDataKeys::StudyDescription.getFirstValue(insertedData),
        medMetaDataKeys::StudyDescription.getFirstValue(m_currentData));
    QCOMPARE(medMetaDataKeys::SeriesDescription.getFirstValue(insertedData), 
        medMetaDataKeys::SeriesDescription.getFirstValue(m_currentData));   
}

void medDataManagerTestObject::compareData(dtkSmartPointer<dtkAbstractData> data1, dtkSmartPointer<dtkAbstractData> data2)
{
    QVERIFY(data1);
    QVERIFY(data2);
    //QCOMPARE(data1->identifier(), data2->identifier());
    QCOMPARE(medMetaDataKeys::PatientName.getFirstValue(data1),
        medMetaDataKeys::PatientName.getFirstValue(data2));
    QCOMPARE(medMetaDataKeys::StudyDescription.getFirstValue(data1), 
        medMetaDataKeys::StudyDescription.getFirstValue(data2));
    QCOMPARE(medMetaDataKeys::SeriesDescription.getFirstValue(data1), 
        medMetaDataKeys::SeriesDescription.getFirstValue(data2));   
}

void medDataManagerTestObject::waitForInsertions(int numberOfInsertions, int timeout )
{
    m_insertedIndexes.clear();
    QSignalSpy spy1 (medDataManager::instance(), SIGNAL(dataAdded(const medDataIndex&)));
    
    QTimer timer1, timer2;
    timer1.setSingleShot(true);
    timer1.start(timeout);
    
    connect(&timer2, SIGNAL(timeout()), &m_eventLoop, SLOT(quit()));
    
    while( spy1.count() < numberOfInsertions && timer1.isActive() )
    {
        timer2.start(5000);
        m_eventLoop.exec();
        m_insertedIndexes.append(m_lastInsertedIndex);
    }
    
    //TODO: in some cases it seems that there are more signals, need to check that
    QVERIFY(spy1.count() >= numberOfInsertions);  
}

void medDataManagerTestObject::waitForDeletions(int numberOfDeletions, int timeout )
{
    m_insertedIndexes.clear();
    QSignalSpy spy1 (medDataManager::instance(), SIGNAL(dataRemoved(const medDataIndex&)));
    
    QTimer timer1, timer2;
    timer1.setSingleShot(true);
    timer1.start(timeout);
    
    connect(&timer2, SIGNAL(timeout()), &m_eventLoop, SLOT(quit()));
    
    while( spy1.count() < numberOfDeletions && timer1.isActive() )
    {
        timer2.start(5000);
        m_eventLoop.exec();
    }
    
    QVERIFY(spy1.count() >= numberOfDeletions);  
}

DTKTEST_MAIN(medDataManagerTest,medDataManagerTestObject)

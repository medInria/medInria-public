// /////////////////////////////////////////////////////////////////
// Generated by dtkPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "itkProcessRegistrationBaloo.h"
#include <dtkCoreSupport/dtkAbstractProcessFactory.h>

// /////////////////////////////////////////////////////////////////
//
// /////////////////////////////////////////////////////////////////

#include "itkImageRegistrationMethod.h"
#include "itkMattesMutualInformationImageToImageMetric.h"
#include "itkLinearInterpolateImageFunction.h"
#include "itkEuler3DTransform.h"
#include "itkCenteredTransformInitializer.h"
#include "itkImage.h"
#include "itkMetaImageIO.h"
#include "itkResampleImageFilter.h"
#include "itkCastImageFilter.h"

#include "itkCommand.h"

#include "time.h"

#include <rpiBaloo.hxx>
#include <rpiCommonTools.hxx>

// /////////////////////////////////////////////////////////////////
// itkProcessRegistrationBalooPrivate
// /////////////////////////////////////////////////////////////////

class itkProcessRegistrationBalooPrivate
{
public:

    itkProcessRegistrationBaloo * proc;
    template <class PixelType>
            int update(void);
    int transformationType ;
    int similarityMeasure;
    int iterations;
    int coarsestLevel;
    int finestLevel;
    float minimalVariance;
    int processors;
    bool doubleIterations;

    float lts;
    bool overstep;
    float blockKeepRatio;
    std::vector<unsigned short>* blockSize;
    std::vector<unsigned short>* blockSpacing;
    std::vector<unsigned short>* NBSize;
    std::vector<unsigned short>* stepSize;

    void * registrationMethod ;
    template<typename PixelType>
           bool writeTransform(const QString& file);
};

// /////////////////////////////////////////////////////////////////
// itkProcessRegistrationBaloo
// /////////////////////////////////////////////////////////////////

itkProcessRegistrationBaloo::itkProcessRegistrationBaloo(void) :
    itkProcessRegistration(),
    d(new itkProcessRegistrationBalooPrivate)
{
    d->proc = this;
    d->transformationType = 0;
    d->blockSize = new std::vector<unsigned short>(3);
    d->blockSpacing = new std::vector<unsigned short>(3);
    d->NBSize = new std::vector<unsigned short>(3);
    d->stepSize = new std::vector<unsigned short>(3);

    //set transform type for the exportation of the transformation to a file
    this->setProperty("transformType","rigid");
}

itkProcessRegistrationBaloo::~itkProcessRegistrationBaloo(void)
{
    d->proc = NULL;
    switch(fixedImageType()){
    //only float will be used here for the moment

    default:
    {
        typedef itk::Image< float, 3 >  RegImageType;
        delete static_cast<rpi::Baloo< RegImageType, RegImageType,
                float > *>(d->registrationMethod);
    }
        break;
    }
    d->registrationMethod = NULL;
    delete d->blockSize;
    delete d->blockSpacing;
    delete d->NBSize;
    delete d->stepSize;
    delete d;
    d = 0;
}

bool itkProcessRegistrationBaloo::registered(void)
{
    return dtkAbstractProcessFactory::instance()->registerProcessType("itkProcessRegistrationBaloo",
              createitkProcessRegistrationBaloo);
}

QString itkProcessRegistrationBaloo::description(void) const
{
    return "Baloo";
}

QString itkProcessRegistrationBaloo::identifier(void) const
{
    return "itkProcessRegistrationBaloo";
}

// /////////////////////////////////////////////////////////////////
// Templated Version of update
// /////////////////////////////////////////////////////////////////

template <typename PixelType>
        int itkProcessRegistrationBalooPrivate::update(void)
{
    typedef itk::Image< PixelType, 3 >  FixedImageType;
    typedef itk::Image< PixelType, 3 >  MovingImageType;
    typedef rpi::Baloo<FixedImageType,MovingImageType> balooType;

    balooType * registration = new balooType ();

    registrationMethod = registration;

    registration->SetFixedImage((const FixedImageType*) proc->fixedImage().GetPointer());
    registration->SetMovingImage((const MovingImageType*) proc->movingImages()[0].GetPointer());

    registration->SetCoarsestPyramidLevel(coarsestLevel);
    registration->SetFinestPyramidLevel(finestLevel);
    registration->SetMinimalVarianceBlockPruning(minimalVariance);
    registration->SetTransformationType(
            static_cast<typename balooType::Transformation>(transformationType));
    registration->SetSimilarityMeasureType(
                static_cast<typename balooType::SimilarityMeasure>
                (similarityMeasure));
    registration->SetNumberOfIterations(iterations);
    registration->SetDoubleNumberOfIterations(doubleIterations);

    //advanced values
    registration->SetNumberOfProcessors(processors);
    registration->SetLTSCutValue(lts);
    registration->SetOversteppingBlocks(overstep);
    registration->SetPercentageOfBlocksToKeep(blockKeepRatio);
    registration->SetHalfBlockSize(*blockSize);
    registration->SetBlockSpacing(*blockSpacing);
    registration->SetNeighborhoodSize(*NBSize);
    registration->SetStepSize(*stepSize);

    // Run the registration
    time_t t1 = clock();
    try {
        registration->StartRegistration();
    }
    catch( std::exception & err )
    {
        qDebug() << "ExceptionObject caught ! (startRegistration)" << err.what();
        return 1;
    }

    time_t t2 = clock();

    qDebug() << "Elasped time: " << (double)(t2-t1)/(double)CLOCKS_PER_SEC;
    emit (proc->progressed(80));

    typedef itk::ResampleImageFilter< MovingImageType,MovingImageType >    ResampleFilterType;
    typename ResampleFilterType::Pointer resampler = ResampleFilterType::New();
    resampler->SetTransform(registration->GetTransformation());
    resampler->SetInput((const MovingImageType*)proc->movingImages()[0].GetPointer());
    //typename FixedImageType::Pointer fixedImage = fixedImage;
    resampler->SetSize( proc->fixedImage()->GetLargestPossibleRegion().GetSize() );
    resampler->SetOutputOrigin( proc->fixedImage()->GetOrigin() );
    resampler->SetOutputSpacing( proc->fixedImage()->GetSpacing() );
    resampler->SetOutputDirection( proc->fixedImage()->GetDirection() );
    resampler->SetDefaultPixelValue( 0 );

    try {
        resampler->Update();
    }
    catch (itk::ExceptionObject &e) {
        qDebug() << "Resampling crashed" << e.GetDescription();
        return 1;
    }

  // typedef  float  OutputPixelType;
  // typedef itk::Image< OutputPixelType, Dimension > OutputImageType;
  // typedef itk::CastImageFilter< FixedImageType, OutputImageType > CastFilterType;
  // typedef itk::ImageFileWriter< MovingImageType >  WriterType;

  // typename WriterType::Pointer      writer =  WriterType::New();
  // CastFilterType::Pointer  caster =  CastFilterType::New();
  // const char* outputImageFilename = "toto.nhdr";

  // writer->SetFileName( outputImageFilename );
  // caster->SetInput( resampler->GetOutput() );
  // writer->SetInput( resampler->GetOutput()   );
  // writer->Update();

  // std::ofstream outfile;
  // const char* transformationMatrixFilename = "/Users/jwintz/Desktop/transfoMat.txt";
  // outfile.open(transformationMatrixFilename, std::ofstream::out);
  // outfile << matrix[0][0] << " " <<  matrix[0][1] << " " <<  matrix[0][2]
  //       		 << " " << offset[0]
  //       		 << std::endl
  //       		 << matrix[1][0] << " " <<  matrix[1][1] << " " <<  matrix[1][2]
  //       		 << " " << offset[1]
  //       		 << std::endl
  //       		 << matrix[2][0] << " " <<  matrix[2][1] << " " <<  matrix[2][2]
  //       		 << " " << offset[2]
  //       		 << std::endl
  //       		 << "0 0 0 1"
  //       		 << std::endl;
  // outfile.close();

    itk::ImageBase<3>::Pointer result = resampler->GetOutput();
    result->DisconnectPipeline();

    if (proc->output())
    {
        proc->output()->setData (result);
    }

    return 0;
}

int itkProcessRegistrationBaloo::update(itkProcessRegistration::ImageType imgType)
{
    if(fixedImage().IsNull() || movingImages().isEmpty()
           || movingImages()[0].IsNull())
    {
        qWarning() << "Either the fixed image or the moving image is Null";
        return 1;
    }

    if (imgType != itkProcessRegistration::FLOAT)
    {
        qWarning() << "The imageType should be float, and it's :"<<imgType;
        return 1;
    }
    return d->update<float>();

//    switch (imgType){
//    case itkProcessRegistration::UCHAR:
//        return d->update<unsigned char>();
//        break;
//    case itkProcessRegistration::CHAR:
//        return d->update<char>();
//        break;
//    case itkProcessRegistration::USHORT:
//        return d->update<unsigned short>();
//        break;
//    case itkProcessRegistration::SHORT:
//        return d->update<short>();
//        break;
//    case itkProcessRegistration::UINT:
//       return d->update<unsigned int>();
//       break;
//    case itkProcessRegistration::INT:
//        return d->update<int>();
//        break;
//    case itkProcessRegistration::ULONG:
//       return d->update<unsigned long>();
//       break;
//    case itkProcessRegistration::LONG:
//        return d->update<long>();
//        break;
//    case itkProcessRegistration::DOUBLE:
//        return d->update<double>();
//        break;
//    default:
//        return d->update<float>();
//        break;
//    }
}


void itkProcessRegistrationBaloo::setTransformationType(const QString& type)
{
    if (!type.compare("rigid",Qt::CaseInsensitive))
        d->transformationType = 0;
    else if(!type.compare("similitude",Qt::CaseInsensitive))
        d->transformationType = 1;
    else if(!type.compare("affine",Qt::CaseInsensitive))
        d->transformationType = 2;
}

void itkProcessRegistrationBaloo::setSimilarityMeasure(const QString& simMeasure)
{
    typedef rpi::Baloo<itk::Image<short,3>,itk::Image<short,3> > balooType;
    if (!simMeasure.compare("SSD",Qt::CaseInsensitive))
         d->similarityMeasure = balooType::MEASURE_SSD;
    else if (!simMeasure.compare("CC",Qt::CaseInsensitive))
        d->similarityMeasure = balooType::MEASURE_CC;
    else if (!simMeasure.compare("SCC",Qt::CaseInsensitive))
        d->similarityMeasure = balooType::MEASURE_SCC;
//    else if (!simMeasure.compare("TSCC",Qt::CaseInsensitive))
//        d->similarityMeasure = balooType::MEASURE_TSCC;
//    else if (!simMeasure.compare("TSCCO",Qt::CaseInsensitive))
//        d->similarityMeasure = balooType::MEASURE_TSCCO;
//    else if (!simMeasure.compare("MSCC",Qt::CaseInsensitive))
//        d->similarityMeasure = balooType::MEASURE_MSCC;
//    else if (!simMeasure.compare("MAXSCC",Qt::CaseInsensitive))
//        d->similarityMeasure = balooType::MEASURE_MAXSCC;
    else
    {
        qWarning()<< "Unknown similarity measure:" << simMeasure;
        d->similarityMeasure = balooType::MEASURE_SSD;
    }
}


void itkProcessRegistrationBaloo::setIterations(const int iterations)
{
    d->iterations = iterations;
}

void itkProcessRegistrationBaloo::setCoarsestLevel(const int level)
{
    d->coarsestLevel = level;
}

void itkProcessRegistrationBaloo::setFinestLevel(const int level)
{
    d->finestLevel = level;
}

void itkProcessRegistrationBaloo::setMinimalVarianceBlockPruning(float var)
{
    d->minimalVariance = var;
}

void itkProcessRegistrationBaloo::setProcessors(const int processors)
{
    d->processors = processors;
}
void itkProcessRegistrationBaloo::setDoubleIterations(const bool doubleIterations)
{
    d->doubleIterations = doubleIterations;
}

void itkProcessRegistrationBaloo::setLts(float lts)
{
    d->lts = lts;
}

void itkProcessRegistrationBaloo::setOverstep(bool overstep)
{
    d->overstep = overstep;
}

void itkProcessRegistrationBaloo::setBlockKeepRatio(float blockKeepRatio)
{
    d->blockKeepRatio = blockKeepRatio;
}

void itkProcessRegistrationBaloo::setBlockSize(unsigned short x, unsigned short y, unsigned short z)
{
    d->blockSize->at(0) = x;
    d->blockSize->at(1) = y;
    d->blockSize->at(2) = z;
}

void itkProcessRegistrationBaloo::setBlockSpacing(unsigned short x, unsigned short y, unsigned short z)
{
    d->blockSpacing->at(0) = x;
    d->blockSpacing->at(1) = y;
    d->blockSpacing->at(2) = z;
}

void itkProcessRegistrationBaloo::setNeighbourhoodSize(unsigned short x, unsigned short y, unsigned short z)
{
    d->NBSize->at(0) = x;
    d->NBSize->at(1) = y;
    d->NBSize->at(2) = z;
}

void itkProcessRegistrationBaloo::setStepSize(unsigned short x, unsigned short y, unsigned short z)
{
    d->stepSize->at(0) = x;
    d->stepSize->at(1) = y;
    d->stepSize->at(2) = z;
}

itk::Transform<double,3,3>::Pointer itkProcessRegistrationBaloo::getTransform()
{
    typedef float PixelType;
    typedef itk::Image< PixelType, 3 > RegImageType;
    //normaly should use long switch cases, but here we know we work with float3 data.
    if (rpi::Baloo<RegImageType,RegImageType> * registration =
            static_cast<rpi::Baloo<RegImageType,RegImageType> *>(d->registrationMethod))
    {
        return registration->GetTransformation();
    }
    else
        return NULL;
}

QString itkProcessRegistrationBaloo::getTitleAndParameters(){
    typedef float PixelType; 
    typedef itk::Image< PixelType, 3 >  FixedImageType;
    typedef itk::Image< PixelType, 3 >  MovingImageType;
    typedef rpi::Baloo<FixedImageType,MovingImageType> balooType;
    balooType * registration = static_cast<balooType*>(d->registrationMethod);

    QString titleAndParameters;
    titleAndParameters += "Baloo\n";
    titleAndParameters += "  Coarset Pyramid Level : " + QString::number(registration->GetCoarsestPyramidLevel()) + "\n";
    titleAndParameters += "  Finest Pyramid Level : " + QString::number(registration->GetFinestPyramidLevel()) + "\n";
    titleAndParameters += "  Minimal Variance Block Pruning : " + QString::number(registration->GetMinimalVarianceBlockPruning()) + "\n";

    switch(registration->GetTransformationType())
    {
    case 0:
        titleAndParameters += "  Tranformation Type : rigid\n";
        break;
    case 1:
        titleAndParameters += "  Tranformation Type : similitude\n";
        break;
    case 2:
        titleAndParameters += "  Tranformation Type : affine\n";
        break;
    default:
        titleAndParameters += "  Tranformation Type : Unknown\n";
    }

    switch(registration->GetSimilarityMeasureType())
    {
    case 0:
        titleAndParameters += "  Similarity Measure Type : SSD\n";
        break;
    case 1:
        titleAndParameters += "  Similarity Measure Type : CC\n";
        break;
    case 2:
        titleAndParameters += "  Similarity Measure Type : SCC\n";
        break;
    default:
        titleAndParameters += "  Similarity Measure Type : Unknown\n";
    }
    
    titleAndParameters += "  Number Of Iterations : " + QString::number(registration->GetNumberOfIterations()) + "\n";
    titleAndParameters += "  Double Number Of Iterations : " + QString::fromStdString(rpi::BooleanToString(registration->GetDoubleNumberOfIterations())) + "\n";
    titleAndParameters += "  Number Of Processors : " + QString::number(registration->GetNumberOfProcessors()) + "\n";
    titleAndParameters += "  LTS Cut Value : " + QString::number(registration->GetLTSCutValue()) + "\n";
    titleAndParameters += "  Overstepping Blocks : " + QString::fromStdString(rpi::BooleanToString(registration->GetOversteppingBlocks())) + "\n";
    titleAndParameters += "  Percentage Of Blocks To Keep : " + QString::number(registration->GetPercentageOfBlocksToKeep()) + "\n";

    titleAndParameters += "  Half Block Size : " + QString::fromStdString(rpi::VectorToString(registration->GetHalfBlockSize())) + "\n";
    titleAndParameters += "  Block Spacing : " + QString::fromStdString(rpi::VectorToString(registration->GetBlockSpacing())) + "\n";
    titleAndParameters += "  Neighborhood Size : " + QString::fromStdString(rpi::VectorToString(registration->GetNeighborhoodSize())) + "\n";
    titleAndParameters += "  Step size : " + QString::fromStdString(rpi::VectorToString(registration->GetStepSize())) + "\n";

    return titleAndParameters;
}

bool itkProcessRegistrationBaloo::writeTransform(const QString& file)
{
    if(!d->registrationMethod)
        return false;
    switch (this->fixedImageType()){
    case itkProcessRegistration::UCHAR:
        return d->writeTransform<unsigned char>(file);
        break;
    case itkProcessRegistration::CHAR:
        return d->writeTransform<char>(file);
        break;
    case itkProcessRegistration::USHORT:
        return d->writeTransform<unsigned short>(file);
        break;
    case itkProcessRegistration::SHORT:
        return d->writeTransform<short>(file);
        break;
    case itkProcessRegistration::UINT:
       return d->writeTransform<unsigned int>(file);
       break;
    case itkProcessRegistration::INT:
        return d->writeTransform<int>(file);
        break;
    case itkProcessRegistration::ULONG:
       return d->writeTransform<unsigned long>(file);
       break;
    case itkProcessRegistration::LONG:
        return d->writeTransform<long>(file);
        break;
    case itkProcessRegistration::DOUBLE:
        return d->writeTransform<double>(file);
        break;
    default:
        return d->writeTransform<float>(file);
        break;
    }
}

template<typename PixelType>
bool itkProcessRegistrationBalooPrivate::writeTransform(const QString& file)
{
    //typedef float PixelType;
    typedef itk::Image< PixelType, 3 > RegImageType;
    typedef double TransformScalarType;

    if (rpi::Baloo<RegImageType,RegImageType> * registration =
            static_cast<rpi::Baloo<RegImageType,RegImageType> *>(registrationMethod))
    {
        try{
            rpi::writeLinearTransformation<TransformScalarType,
                    RegImageType::ImageDimension>(
                        registration->GetTransformation(),
                        file.toStdString());
        }
        catch (std::exception)
        {
            return false;
        }
        return true;
    }
    else
    {
        return false;
    }
}
// /////////////////////////////////////////////////////////////////
// Type instanciation
// /////////////////////////////////////////////////////////////////

dtkAbstractProcess *createitkProcessRegistrationBaloo(void)
{
    return new itkProcessRegistrationBaloo;
}

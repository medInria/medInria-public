// /////////////////////////////////////////////////////////////////
// Generated by dtkPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "itkProcessRegistrationSuperBaloo.h"
#include <dtkCoreSupport/dtkAbstractProcessFactory.h>

// /////////////////////////////////////////////////////////////////
//
// /////////////////////////////////////////////////////////////////

#include "itkImageRegistrationMethod.h"
#include "itkMattesMutualInformationImageToImageMetric.h"
#include "itkLinearInterpolateImageFunction.h"
#include "itkEuler3DTransform.h"
#include "itkCenteredTransformInitializer.h"

#include "itkImage.h"
#include "itkMetaImageIO.h"
#include "itkResampleImageFilter.h"
#include "itkCastImageFilter.h"

#include "itkCommand.h"

#include "time.h"

#include <rpiSuperBaloo.hxx>
#include <rpiCommonTools.hxx>

// /////////////////////////////////////////////////////////////////
// itkProcessRegistrationSuperBalooPrivate
// /////////////////////////////////////////////////////////////////

class itkProcessRegistrationSuperBalooPrivate
{
public:

    itkProcessRegistrationSuperBaloo * proc;
    template <class PixelType>
            int update(void);
    int similarityMeasure;
    int iterations;
    int coarsestLevel;
    int finestLevel;
    float minimalVariance;
    int processors;
    bool doubleIterations;
    float lts;
    bool overstep;
    float blockKeepRatio;
    std::vector<unsigned short>* blockSize;
    std::vector<unsigned short>* blockSpacing;
    std::vector<unsigned short>* NBSize;
    std::vector<unsigned short>* stepSize;
    float alpha;
    float varianceFluidReg;
    float varianceElasticReg;
    void * registrationMethod ;
    template<typename PixelType>
           bool writeTransform(const QString& file);

};

// /////////////////////////////////////////////////////////////////
// itkProcessRegistrationSuperBaloo
// /////////////////////////////////////////////////////////////////

itkProcessRegistrationSuperBaloo::itkProcessRegistrationSuperBaloo(void) :
    itkProcessRegistration(), d(new itkProcessRegistrationSuperBalooPrivate)
{
    d->proc = this;
    d->blockSize = new std::vector<unsigned short>(3);
    d->blockSpacing = new std::vector<unsigned short>(3);
    d->NBSize = new std::vector<unsigned short>(3);
    d->stepSize = new std::vector<unsigned short>(3);

    //set transform type for the exportation of the transformation to a file
    this->setProperty("transformType","nonRigid");
}

itkProcessRegistrationSuperBaloo::~itkProcessRegistrationSuperBaloo(void)
{
    d->proc = NULL;
    switch(fixedImageType()){
    //only float will be used here for the moment

    default:
    {
        typedef itk::Image< float, 3 >  RegImageType;
        delete static_cast<rpi::SuperBaloo< RegImageType, RegImageType,
                float > *>(d->registrationMethod);
    }
        break;
    }
    d->registrationMethod = NULL;
    delete d->blockSize;
    delete d->blockSpacing;
    delete d->NBSize;
    delete d->stepSize;
    delete d;
    d = 0;
}

bool itkProcessRegistrationSuperBaloo::registered(void)
{
    return dtkAbstractProcessFactory::instance()->registerProcessType("itkProcessRegistrationSuperBaloo",
              createitkProcessRegistrationSuperBaloo);
}

QString itkProcessRegistrationSuperBaloo::description(void) const
{
    return "Super Baloo";
}

QString itkProcessRegistrationSuperBaloo::identifier(void) const
{
    return "itkProcessRegistrationSuperBaloo";
}

// /////////////////////////////////////////////////////////////////
// Templated Version of update
// /////////////////////////////////////////////////////////////////

template <typename PixelType>
        int itkProcessRegistrationSuperBalooPrivate::update(void)
{
    typedef itk::Image< PixelType, 3 >  FixedImageType;
    typedef itk::Image< PixelType, 3 >  MovingImageType;
    typedef rpi::SuperBaloo<FixedImageType,MovingImageType> superBalooType;

    superBalooType * registration = new superBalooType ();

    registrationMethod = registration;

    registration->SetFixedImage((const FixedImageType*) proc->fixedImage().GetPointer());
    registration->SetMovingImage((const MovingImageType*) proc->movingImages()[0].GetPointer());

    registration->SetCoarsestPyramidLevel(coarsestLevel);
    registration->SetFinestPyramidLevel(finestLevel);
    registration->SetMinimalVarianceBlockPruning(minimalVariance);
    registration->SetSimilarityMeasureType(
                static_cast<typename superBalooType::SimilarityMeasure>
                (similarityMeasure));
    registration->SetNumberOfIterations(iterations);
    registration->SetDoubleNumberOfIterations(doubleIterations);

    //advanced values
    registration->SetNumberOfProcessors(processors);
    registration->SetLTSCutValue(lts);
    registration->SetOversteppingBlocks(overstep);
    registration->SetPercentageOfBlocksToKeep(blockKeepRatio);
    registration->SetHalfBlockSize(*blockSize);
    registration->SetBlockSpacing(*blockSpacing);
    registration->SetNeighborhoodSize(*NBSize);
    registration->SetStepSize(*stepSize);
    registration->SetAlpha(alpha);
    registration->SetElasticVarianceRegularization(varianceElasticReg);
    registration->SetFluidVarianceRegularization(varianceFluidReg);

    // Run the registration
    time_t t1 = clock();
    try {
        registration->StartRegistration();
    }
    catch( std::exception & err )
    {
        qDebug() << "ExceptionObject caught ! (startRegistration)" << err.what();
        return 1;
    }

    time_t t2 = clock();

    qDebug() << "Elasped time: " << (double)(t2-t1)/(double)CLOCKS_PER_SEC;
    emit (proc->progressed(80));

    typedef itk::ResampleImageFilter< MovingImageType,MovingImageType >    ResampleFilterType;
    typename ResampleFilterType::Pointer resampler = ResampleFilterType::New();
    resampler->SetTransform(registration->GetTransformation());
    resampler->SetInput((const MovingImageType*)proc->movingImages()[0].GetPointer());
    //typename FixedImageType::Pointer fixedImage = fixedImage;
    resampler->SetSize( proc->fixedImage()->GetLargestPossibleRegion().GetSize() );
    resampler->SetOutputOrigin( proc->fixedImage()->GetOrigin() );
    resampler->SetOutputSpacing( proc->fixedImage()->GetSpacing() );
    resampler->SetOutputDirection( proc->fixedImage()->GetDirection() );
    resampler->SetDefaultPixelValue( 0 );

    try {
        resampler->Update();
    }
    catch (itk::ExceptionObject &e) {
        qDebug() << "Resampling crashed" << e.GetDescription();
        return 1;
    }

  // typedef  float  OutputPixelType;
  // typedef itk::Image< OutputPixelType, Dimension > OutputImageType;
  // typedef itk::CastImageFilter< FixedImageType, OutputImageType > CastFilterType;
  // typedef itk::ImageFileWriter< MovingImageType >  WriterType;

  // typename WriterType::Pointer      writer =  WriterType::New();
  // CastFilterType::Pointer  caster =  CastFilterType::New();
  // const char* outputImageFilename = "toto.nhdr";

  // writer->SetFileName( outputImageFilename );
  // caster->SetInput( resampler->GetOutput() );
  // writer->SetInput( resampler->GetOutput()   );
  // writer->Update();

  // std::ofstream outfile;
  // const char* transformationMatrixFilename = "/Users/jwintz/Desktop/transfoMat.txt";
  // outfile.open(transformationMatrixFilename, std::ofstream::out);
  // outfile << matrix[0][0] << " " <<  matrix[0][1] << " " <<  matrix[0][2]
  //       		 << " " << offset[0]
  //       		 << std::endl
  //       		 << matrix[1][0] << " " <<  matrix[1][1] << " " <<  matrix[1][2]
  //       		 << " " << offset[1]
  //       		 << std::endl
  //       		 << matrix[2][0] << " " <<  matrix[2][1] << " " <<  matrix[2][2]
  //       		 << " " << offset[2]
  //       		 << std::endl
  //       		 << "0 0 0 1"
  //       		 << std::endl;
  // outfile.close();

    itk::ImageBase<3>::Pointer result = resampler->GetOutput();
    result->DisconnectPipeline();

    if (proc->output())
    {
        proc->output()->setData (result);
    }

    return 0;
}

int itkProcessRegistrationSuperBaloo::update(itkProcessRegistration::ImageType imgType)
{
    if(fixedImage().IsNull() || movingImages().isEmpty()
            || movingImages()[0].IsNull())
    {
        qWarning() << "Either the fixed image or the moving image is Null";
        return 1;
    }

    if (imgType != itkProcessRegistration::FLOAT)
    {
        qWarning() << "the imageType should be float, and it's :"<<imgType;
        return 1;
    }

    return d->update<float>();
//    if(fixedImage().IsNull() || movingImages().isEmpty()
//           || movingImages()[0].IsNull())
//        return 1;
//    switch (imgType){
//    case itkProcessRegistration::UCHAR:
//        return d->update<unsigned char>();
//        break;
//    case itkProcessRegistration::CHAR:
//        return d->update<char>();
//        break;
//    case itkProcessRegistration::USHORT:
//        return d->update<unsigned short>();
//        break;
//    case itkProcessRegistration::SHORT:
//        return d->update<short>();
//        break;
//    case itkProcessRegistration::UINT:
//       return d->update<unsigned int>();
//       break;
//    case itkProcessRegistration::INT:
//        return d->update<int>();
//        break;
//    case itkProcessRegistration::ULONG:
//       return d->update<unsigned long>();
//       break;
//    case itkProcessRegistration::LONG:
//        return d->update<long>();
//        break;
//    case itkProcessRegistration::DOUBLE:
//        return d->update<double>();
//        break;
//    default:
//        return d->update<float>();
//        break;
//    }
}


void itkProcessRegistrationSuperBaloo::setSimilarityMeasure(const QString& simMeasure)
{
    typedef rpi::SuperBaloo<itk::Image<short,3>,itk::Image<short,3> > superBalooType;
    if (!simMeasure.compare("SSD",Qt::CaseInsensitive))
         d->similarityMeasure = superBalooType::MEASURE_SSD;
    else if (!simMeasure.compare("CC",Qt::CaseInsensitive))
        d->similarityMeasure = superBalooType::MEASURE_CC;
    else if (!simMeasure.compare("SCC",Qt::CaseInsensitive))
        d->similarityMeasure = superBalooType::MEASURE_SCC;
    else if (!simMeasure.compare("TSCC",Qt::CaseInsensitive))
        d->similarityMeasure = superBalooType::MEASURE_TSCC;
    else if (!simMeasure.compare("TSCCO",Qt::CaseInsensitive))
        d->similarityMeasure = superBalooType::MEASURE_TSCCO;
    else if (!simMeasure.compare("MSCC",Qt::CaseInsensitive))
        d->similarityMeasure = superBalooType::MEASURE_MSCC;
    else if (!simMeasure.compare("MAXSCC",Qt::CaseInsensitive))
        d->similarityMeasure = superBalooType::MEASURE_MAXSCC;
    else
    {
        qWarning()<< "Unknown similarity measure:" << simMeasure;
        d->similarityMeasure = superBalooType::MEASURE_SSD;
    }
}


void itkProcessRegistrationSuperBaloo::setIterations(const int iterations)
{
    d->iterations = iterations;
}

void itkProcessRegistrationSuperBaloo::setCoarsestLevel(const int level)
{
    d->coarsestLevel = level;
}

void itkProcessRegistrationSuperBaloo::setFinestLevel(const int level)
{
    d->finestLevel = level;
}

void itkProcessRegistrationSuperBaloo::setMinimalVarianceBlockPruning(float var)
{
    d->minimalVariance = var;
}

void itkProcessRegistrationSuperBaloo::setProcessors(const int processors)
{
    d->processors = processors;
}
void itkProcessRegistrationSuperBaloo::setDoubleIterations(const bool doubleIterations)
{
    d->doubleIterations = doubleIterations;
}

void itkProcessRegistrationSuperBaloo::setLts(float lts)
{
    d->lts = lts;
}

void itkProcessRegistrationSuperBaloo::setOverstep(bool overstep)
{
    d->overstep = overstep;
}

void itkProcessRegistrationSuperBaloo::setBlockKeepRatio(float blockKeepRatio)
{
    d->blockKeepRatio = blockKeepRatio;
}

void itkProcessRegistrationSuperBaloo::setBlockSize(unsigned short x, unsigned short y, unsigned short z)
{
    d->blockSize->at(0) = x;
    d->blockSize->at(1) = y;
    d->blockSize->at(2) = z;
}

void itkProcessRegistrationSuperBaloo::setBlockSpacing(unsigned short x, unsigned short y, unsigned short z)
{
    d->blockSpacing->at(0) = x;
    d->blockSpacing->at(1) = y;
    d->blockSpacing->at(2) = z;
}

void itkProcessRegistrationSuperBaloo::setNeighbourhoodSize(unsigned short x, unsigned short y, unsigned short z)
{
    d->NBSize->at(0) = x;
    d->NBSize->at(1) = y;
    d->NBSize->at(2) = z;
}

void itkProcessRegistrationSuperBaloo::setStepSize(unsigned short x, unsigned short y, unsigned short z)
{
    d->stepSize->at(0) = x;
    d->stepSize->at(1) = y;
    d->stepSize->at(2) = z;
}

void itkProcessRegistrationSuperBaloo::setAlpha(float alpha)
{
    d->alpha = alpha;
}

void itkProcessRegistrationSuperBaloo::setElasticVarianceRegularisation(float variance)
{
    d->varianceElasticReg = variance;
}

void itkProcessRegistrationSuperBaloo::setFluidVarianceRegularisation(float variance)
{
    d->varianceFluidReg = variance;
}

itk::Transform<double,3,3>::Pointer itkProcessRegistrationSuperBaloo::getTransform()
{
    typedef float PixelType;
    typedef itk::Image< PixelType, 3 > RegImageType;
    //normaly should use long switch cases, but here we know we work with float3 data.
    if (rpi::SuperBaloo<RegImageType,RegImageType> * registration =
            static_cast<rpi::SuperBaloo<RegImageType,RegImageType> *>(d->registrationMethod))
    {
        return registration->GetTransformation();
    }
    else
        return NULL;
}

QString itkProcessRegistrationSuperBaloo::getTitleAndParameters(){
    typedef float PixelType; 
    typedef itk::Image< PixelType, 3 >  FixedImageType;
    typedef itk::Image< PixelType, 3 >  MovingImageType;
    typedef rpi::SuperBaloo<FixedImageType,MovingImageType> superBalooType;
    superBalooType * registration = static_cast<superBalooType*>(d->registrationMethod);

    QString titleAndParameters;
    titleAndParameters += "SuperBaloo\n";
    
    titleAndParameters += "  Coarset Pyramid Level : " + QString::number(registration->GetCoarsestPyramidLevel());
    titleAndParameters += "  Finest Pyramid Level : " + QString::number(registration->GetFinestPyramidLevel());
    titleAndParameters += "  Minimal Variance Block Pruning : " + QString::number(registration->GetMinimalVarianceBlockPruning());
    
    switch(registration->GetSimilarityMeasureType())
    {
    case 0:                                  
        titleAndParameters += "  Similarity Measure Type : SSD\n";
        break;
    case 1:
        titleAndParameters += "  Similarity Measure Type : CC\n";
        break;
    case 2:
        titleAndParameters += "  Similarity Measure Type : SCC\n";
        break;
    case 3:
        titleAndParameters += "  Similarity Measure Type : TSCC\n";
        break;
    case 4:
        titleAndParameters += "  Similarity Measure Type : TSCCO\n";
        break;
    case 5:
        titleAndParameters += "  Similarity Measure Type : MSCC\n";
        break;
    case 6:
        titleAndParameters += "  Similarity Measure Type : MAXSCC\n";
        break;
    default:
        titleAndParameters += "  Similarity Measure Type : Unknown\n";
    }

    titleAndParameters += "  Number Of Iterations : " + QString::number(registration->GetNumberOfIterations());
    titleAndParameters += "  Double Number Of Iterations : " + QString::fromStdString(rpi::BooleanToString(registration->GetDoubleNumberOfIterations()));
    titleAndParameters += "  Number Of Processors : " + QString::number(registration->GetNumberOfProcessors());
    titleAndParameters += "  LTS Cut Value : " + QString::number(registration->GetLTSCutValue());
    titleAndParameters += "  Overstepping Blocks : " + QString::fromStdString(rpi::BooleanToString(registration->GetOversteppingBlocks()));
    titleAndParameters += "  Percentage Of Blocks To Keep : " + QString::number(registration->GetPercentageOfBlocksToKeep());

    titleAndParameters += "  Half Block Size : " + QString::fromStdString(rpi::VectorToString(registration->GetHalfBlockSize()));
    titleAndParameters += "  Neighborhood Size : " + QString::fromStdString(rpi::VectorToString(registration->GetNeighborhoodSize()));
    titleAndParameters += "  Step size : " + QString::fromStdString(rpi::VectorToString(registration->GetStepSize()));

    titleAndParameters += "  Alpha : " + QString::number(registration->GetAlpha());
    titleAndParameters += "  Elastic Variance Regularization : " + QString::number(registration->GetElasticVarianceRegularization());
    titleAndParameters += "  Fluid Variance Regularization : " + QString::number(registration->GetFluidVarianceRegularization());
    
    return titleAndParameters;
}

bool itkProcessRegistrationSuperBaloo::writeTransform(const QString& file)
{
    if(!d->registrationMethod)
        return false;
    switch (this->fixedImageType()){
//    case itkProcessRegistration::UCHAR:
//        return d->writeTransform<unsigned char>(file);
//        break;
//    case itkProcessRegistration::CHAR:
//        return d->writeTransform<char>(file);
//        break;
//    case itkProcessRegistration::USHORT:
//        return d->writeTransform<unsigned short>(file);
//        break;
//    case itkProcessRegistration::SHORT:
//        return d->writeTransform<short>(file);
//        break;
//    case itkProcessRegistration::UINT:
//       return d->writeTransform<unsigned int>(file);
//       break;
//    case itkProcessRegistration::INT:
//        return d->writeTransform<int>(file);
//        break;
//    case itkProcessRegistration::ULONG:
//       return d->writeTransform<unsigned long>(file);
//       break;
//    case itkProcessRegistration::LONG:
//        return d->writeTransform<long>(file);
//        break;
//    case itkProcessRegistration::DOUBLE:
//        return d->writeTransform<double>(file);
//        break;
    default:
        return d->writeTransform<float>(file);
        break;
    }
}

template<typename PixelType>
bool itkProcessRegistrationSuperBalooPrivate::writeTransform(const QString& file)
{
    //typedef float PixelType;
    typedef itk::Image< PixelType, 3 > RegImageType;
    typedef double TransformScalarType;

    if (rpi::SuperBaloo<RegImageType,RegImageType> * registration =
            static_cast<rpi::SuperBaloo<RegImageType,RegImageType> *>(registrationMethod))
    {
        try{
            rpi::writeDisplacementFieldTransformation<TransformScalarType,
                    RegImageType::ImageDimension>(
                        registration->GetTransformation(),
                        file.toStdString());
        }
        catch (std::exception)
        {
            return false;
        }
        return true;
    }
    else
    {
        return false;
    }
}


// /////////////////////////////////////////////////////////////////
// Type instanciation
// /////////////////////////////////////////////////////////////////

dtkAbstractProcess *createitkProcessRegistrationSuperBaloo(void)
{
    return new itkProcessRegistrationSuperBaloo;
}




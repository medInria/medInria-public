// /////////////////////////////////////////////////////////////////
// Generated by dtkPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "itkProcessRegistrationILogDemons.h"
#include <dtkCoreSupport/dtkAbstractProcessFactory.h>
#include <dtkCoreSupport/dtkAbstractData.h>

// /////////////////////////////////////////////////////////////////
//
// /////////////////////////////////////////////////////////////////

#include <itkImageRegistrationMethod.h>
#include <itkMattesMutualInformationImageToImageMetric.h>
#include <itkLinearInterpolateImageFunction.h>
#include <itkEuler3DTransform.h>
#include <itkCenteredTransformInitializer.h>

#include <itkImage.h>
#include <itkMetaImageIO.h>
#include <itkResampleImageFilter.h>
#include <itkCastImageFilter.h>

#include <itkCommand.h>
#include <itkTensor.h>

#include <rpiDisplacementFieldTransform.h>
#include <itkStationaryVelocityFieldTransform.h>

#include <rpiIncompressibleLogDemons.hxx>
#include <rpiCommonTools.hxx>

#include "time.h"

// /////////////////////////////////////////////////////////////////
// itkProcessRegistrationILogDemonsPrivate
// /////////////////////////////////////////////////////////////////


class itkProcessRegistrationILogDemonsPrivate
{
public:

    itkProcessRegistrationILogDemons * proc;
    template <class PixelType>
    int update(void);
    template < typename TFixedImage, typename TMovingImage >
    bool write(const QString&);
    void * registrationMethod ;

    std::vector<unsigned int> iterations;

    dtkAbstractData * maskData;
    int           minIterations;
    float         maximumUpdateStepLength;
    unsigned int  gradientType;
    float         upFieldSigma;
    unsigned int  upFieldInc;
    float         upFieldKappa;
    float         velFieldSigma;
    unsigned int  velFieldInc;
    float         velFieldKappa;
    bool          useHistogramMatching;
    unsigned int  BCHExpansion;
    std::vector<float>   stop;
    float         spatialDerivativeSigma;
    unsigned int  stepSize;
    float         DTIStandardDeviation;
    unsigned int  noiseEstimatorType;
    float         noiseEstimatorSigma;
    bool          noiseEstimatorLM;
    float         noiseEstimatorEpsilon;
};

// /////////////////////////////////////////////////////////////////
// itkProcessRegistrationILogDemons
// /////////////////////////////////////////////////////////////////

itkProcessRegistrationILogDemons::itkProcessRegistrationILogDemons(void) : itkProcessRegistration(), d(new itkProcessRegistrationILogDemonsPrivate)
{

    d->proc = this;
    d->registrationMethod = NULL;
    d->minIterations = -1;
    d->maximumUpdateStepLength = 2.0;
    d->gradientType = 0;
    d->upFieldSigma = 0.5;
    d->upFieldInc = 0;
    d->upFieldKappa = 0.0;
    d->velFieldSigma = 1.5;
    d->velFieldInc = 1;
    d->velFieldKappa = 0.0;
    d->useHistogramMatching = false;
    d->BCHExpansion = 2;
    d->spatialDerivativeSigma = 0.5;
    d->stepSize = 5;
    d->DTIStandardDeviation = 1.0;
    d->noiseEstimatorType =0;
    d->noiseEstimatorSigma = 5.0;
    d->noiseEstimatorLM = false;
    d->noiseEstimatorEpsilon = 0.0;
    d->maskData = NULL;

    //set transform type for the exportation of the transformation to a file
    this->setProperty("transformType","nonRigid");
}

itkProcessRegistrationILogDemons::~itkProcessRegistrationILogDemons(void)
{
    d->proc = NULL;
    d->registrationMethod = NULL;
    delete d;
    d = NULL;
}

bool itkProcessRegistrationILogDemons::registered(void)
{
    return dtkAbstractProcessFactory::instance()->registerProcessType("itkProcessRegistrationILogDemons",
        createitkProcessRegistrationILogDemons);
}

QString itkProcessRegistrationILogDemons::description(void) const
{
    return "itkProcessRegistrationILogDemons";
}

// /////////////////////////////////////////////////////////////////
// Templated Version of update
// /////////////////////////////////////////////////////////////////

template <typename PixelType>
int itkProcessRegistrationILogDemonsPrivate::update(void)
{


    typedef itk::Image< PixelType, 3 >  FixedImageTypeInput;
    typedef itk::Image< PixelType, 3 >  MovingImageTypeInput;


    typedef itk::Image< float, 3 > FixedImageType;
    typedef itk::Image< float, 3 > MovingImageType;
    typedef itk::Image< float, 3 > RegImageType;

    typedef double TransformScalarType;
    //we force the use of a binary mask (or at least in integers in [0-255])
    typedef unsigned char MaskPixelType;

    typedef itk::Image<MaskPixelType, 3> MaskType;

    typedef rpi::IncompressibleLogDemons< RegImageType, RegImageType, TransformScalarType, MaskPixelType > RegistrationType;

    //////

    typedef itk::Transform<TransformScalarType, 3, 3> LinearTransformType;

    typedef itk::StationaryVelocityFieldTransform< TransformScalarType, 3 > StationaryVelocityFieldTransformType;

    typedef rpi::DisplacementFieldTransform< TransformScalarType, 3 > DisplacementFieldTransformType;

    /////
    typedef itk::CastImageFilter< FixedImageTypeInput, FixedImageType > CasterFilterFixedType;
    typename CasterFilterFixedType::Pointer  casterFix =  CasterFilterFixedType::New();
    casterFix->SetInput(dynamic_cast<FixedImageTypeInput*>(proc->fixedImage().GetPointer()));
    casterFix->Update();
    typename FixedImageType::Pointer fixedImage = casterFix->GetOutput();

    typedef itk::CastImageFilter< MovingImageTypeInput, RegImageType > CastFilterMovingType;
    typename CastFilterMovingType::Pointer  casterMov =  CastFilterMovingType::New();
    casterMov->SetInput(dynamic_cast<MovingImageTypeInput*>(proc->movingImages()[0].GetPointer()));
    casterMov->Update();
    typename MovingImageType::Pointer movingImage = casterMov->GetOutput();

    RegistrationType * registration = new RegistrationType;

    registrationMethod = registration;

    registration->SetFixedImage(fixedImage);
    registration->SetMovingImage(movingImage);

    registration->SetNumberOfIterations(iterations);
    registration->SetMinimumNumberOfIterations(minIterations);
    registration->SetMaximumUpdateStepLength(maximumUpdateStepLength);
    registration->SetUpdateFieldStandardDeviation(upFieldSigma);
    registration->SetUpdateFieldKappa(upFieldKappa);
    registration->SetStationaryVelocityFieldStandardDeviation(velFieldSigma);
    registration->SetStationaryVelocityFieldKappa(velFieldKappa);
    registration->SetUseHistogramMatching(useHistogramMatching);
    registration->SetNumberOfTermsBCHExpansion(BCHExpansion);
    registration->SetStopThreshold(stop);
    registration->SetSpatialDerivativeStandardDeviation(spatialDerivativeSigma);
    registration->SetAlternateProjectionStepSize(stepSize);
    registration->SetHessianProjectionTensorStandardDeviation(DTIStandardDeviation);
    registration->SetNoiseEstimatorStandardDeviation(noiseEstimatorSigma);
    registration->SetNoiseEstimatorLM(noiseEstimatorLM);
    registration->SetNoiseEstimatorEpsilon(noiseEstimatorEpsilon);
    if(maskData)
        registration->SetMask(dynamic_cast<MaskType*>(maskData));
    switch( gradientType )
    {
    case 0:
        registration->SetGradientType( RegistrationType::GRADIENT_SYMMETRIZED );         break;
    case 1:
        registration->SetGradientType( RegistrationType::GRADIENT_FIXED_IMAGE );         break;
    case 2:
        registration->SetGradientType( RegistrationType::GRADIENT_WARPED_MOVING_IMAGE ); break;
    case 3:
        registration->SetGradientType( RegistrationType::GRADIENT_MAPPED_MOVING_IMAGE ); break;
    default:
        throw std::runtime_error( "Gradient type must fit in the range [0,3]." );
    }


    switch( upFieldInc )
    {
    case 0:
        registration->SetUpdateFieldIncompressibility( RegistrationType::UP_INCOMPRESSIBILITY_DISABLED );
        break;
    case 1:
        registration->SetUpdateFieldIncompressibility( RegistrationType::UP_INCOMPRESSIBILITY_L2_NORM_PROJECTION );
        break;
    case 2:
        registration->SetUpdateFieldIncompressibility( RegistrationType::UP_INCOMPRESSIBILITY_HESSIAN_NORM_PROJECTION );
        break;
    case 3:
        registration->SetUpdateFieldIncompressibility( RegistrationType::UP_INCOMPRESSIBILITY_ALTERNATE_PROJECTION );
        break;
    default:
        throw std::runtime_error( "Incompressibility type of the update field must fit in the range [0,3]." );
    }

    switch( velFieldInc )
    {
    case 0:
        registration->SetStationaryVelocityFieldIncompressibility( RegistrationType::VEL_INCOMPRESSIBILITY_DISABLED );
        break;
    case 1:
        registration->SetStationaryVelocityFieldIncompressibility( RegistrationType::VEL_INCOMPRESSIBILITY_ENABLED );
        break;
    default:
        throw std::runtime_error( "Incompressibility type of the stationary velocity field must fit in the range [0,1]." );
    }

    switch( noiseEstimatorType )
    {
    case 0:
        registration->SetNoiseEstimatorType( RegistrationType::NOISE_ESTIMATOR_LOCAL );
        break;
    case 1:
        registration->SetNoiseEstimatorType( RegistrationType::NOISE_ESTIMATOR_REGIONAL );
        break;
    case 2:
        registration->SetNoiseEstimatorType( RegistrationType::NOISE_ESTIMATOR_GLOBAL );
        break;
    default:
        throw std::runtime_error( "Noise estimator type must fit in the range [0,2]." );
    }
    
    // Run the registration
    time_t t1 = clock();
    try {
        registration->StartRegistration();
    }
    catch( std::exception & err )
    {
        qDebug() << "ExceptionObject caught ! (startRegistration)" << err.what();
        return 1;
    }

    time_t t2 = clock();

    qDebug() << "Elasped time: " << (double)(t2-t1)/(double)CLOCKS_PER_SEC;


    typename DisplacementFieldTransformType::Pointer  df  = DisplacementFieldTransformType::New();
    typename StationaryVelocityFieldTransformType::Pointer svf = dynamic_cast<StationaryVelocityFieldTransformType*>(registration->GetTransformation().GetPointer());
    df->SetParametersAsVectorField( svf->GetDisplacementFieldAsVectorField() );

    typedef itk::ResampleImageFilter< MovingImageType, FixedImageType,TransformScalarType >    ResampleFilterType;
    typename ResampleFilterType::Pointer resampler = ResampleFilterType::New();
    resampler->SetTransform(df );

    //resampler->SetInput((const MovingImageType*)proc->movingImage().GetPointer());


    //resampler->SetInput((const FixedImageType*)extractFilter->GetOutput());

    resampler->SetInput(movingImage);
    //resampler->SetSize( proc->fixedImage()->GetLargestPossibleRegion().GetSize() );
    //resampler->SetOutputOrigin( proc->fixedImage()->GetOrigin() );
    //resampler->SetOutputSpacing( proc->fixedImage()->GetSpacing() );
    //resampler->SetOutputDirection( proc->fixedImage()->GetDirection() );

    resampler->SetSize( fixedImage->GetLargestPossibleRegion().GetSize() );
    resampler->SetOutputOrigin( fixedImage->GetOrigin() );
    resampler->SetOutputSpacing( fixedImage->GetSpacing() );
    resampler->SetOutputDirection( fixedImage->GetDirection() );
    resampler->SetDefaultPixelValue( 0 );

    qDebug() << "RESAMP1";
    try {
        resampler->Update();
    }
    catch (itk::ExceptionObject &e) {
        qDebug() << e.GetDescription();
        return 1;
    }
    qDebug() << "RESAMP1 after try catch";

    itk::ImageBase<3>::Pointer result = resampler->GetOutput();

    qDebug() << "Resampled? ";
    result->Print(std::cout);
    result->DisconnectPipeline();

    if (proc->output())
    {
        qDebug() << "before output->setData";
        proc->output()->setData (result);
        qDebug() << "after output->setData";
    }

    return 0;


}



int itkProcessRegistrationILogDemons::update(itkProcessRegistration::ImageType imgType)
{
    if(fixedImage().IsNull() || movingImages().isEmpty()
            || movingImages()[0].IsNull())
    {
        qWarning() << "Either the fixed image or the moving image is Null";
        return 1;
    }

    if (imgType != itkProcessRegistration::FLOAT)
    {
        qWarning() << "the imageType should be float, and it's :"<<imgType;
        return 1;
    }

    return d->update<float>();
}

itk::Transform<double,3,3>::Pointer itkProcessRegistrationILogDemons::getTransform()
{
    typedef float PixelType;
    typedef double TransformScalarType;
    typedef double MaskPixelType;
    typedef itk::Image< PixelType, 3 > RegImageType;
    //normaly should use long switch cases, but here we know we work with float3 data.
    if (rpi::IncompressibleLogDemons< RegImageType, RegImageType, TransformScalarType, MaskPixelType > * registration =
            static_cast<rpi::IncompressibleLogDemons< RegImageType, RegImageType, TransformScalarType, MaskPixelType > *>(d->registrationMethod))
    {
        return registration->GetTransformation();
    }
    else
        return nullptr;
}

QString itkProcessRegistrationILogDemons::getTitleAndParameters(){
    typedef float PixelType;
    typedef double TransformScalarType;
    typedef double MaskPixelType;
    typedef itk::Image< PixelType, 3 > RegImageType;

    typedef rpi::IncompressibleLogDemons< RegImageType, RegImageType, TransformScalarType, MaskPixelType > RegistrationType;

    RegistrationType * registration = static_cast<RegistrationType *>(d->registrationMethod);
    
    QString titleAndParameters;
    titleAndParameters += "ILogDemons\n";

    titleAndParameters += "  Iterations : " + QString::fromStdString(rpi::VectorToString(registration->GetNumberOfIterations())) + "\n";
    titleAndParameters += "  Minimum iterations : " + QString::number(registration->GetMinimumNumberOfIterations()) + "\n";
    titleAndParameters += "  Maximum step length : " + QString::number(registration->GetMaximumUpdateStepLength()) + "\n";
    switch( registration->GetGradientType() )
    {
    case 0:
        titleAndParameters += "  Gradient type : SYMMETRIZED\n";     break;
    case 1:
        titleAndParameters += "  Gradient type : FIXED_IMAGE\n";         break;
    case 2:
        titleAndParameters += "  Gradient type : WARPED_MOVING_IMAGE \n"; break;
    case 3:
        titleAndParameters += "  Gradient type : MAPPED_MOVING_IMAGE\n"; break;
    default:
        titleAndParameters += "  Gradient type : Unknown \n";
    }

    titleAndParameters += "  Update field standard deviation              : " + QString::number(registration->GetUpdateFieldStandardDeviation()) + "\n";
    
    switch( registration->GetUpdateFieldIncompressibility())
    {
    case 0:
        titleAndParameters += "  Update field incompressibility : DISABLED\n" ; break;
    case 1:
        titleAndParameters += "  Update field incompressibility : L2_NORM_PROJECTION\n" ; break;
    case 2:
        titleAndParameters += "  Update field incompressibility : HESSIAN_NORM_PROJECTION\n"; break;
    case 3:
        titleAndParameters += "  Update field incompressibility : ALTERNATE_PROJECTION\n"; break;
    default:
        titleAndParameters += "  Update field incompressibility : Unknown\n";
    }
    titleAndParameters += "  Update field kappa : " + QString::number(registration->GetUpdateFieldKappa()) + "\n";
    titleAndParameters += "  Stationary velocity field standard deviation : " + QString::number(registration->GetStationaryVelocityFieldStandardDeviation()) + "\n";
    
    switch( registration->GetStationaryVelocityFieldIncompressibility() )
    {
    case 0:
        titleAndParameters += "  Stationary velocity field incompressibility : DISABLED\n"; break;
    case 1:
        titleAndParameters += "  Stationary velocity field incompressibility : ENABLED\n"; break;
    default:
        titleAndParameters += "  Stationary velocity field incompressibility : Unknown\n";
    }

    titleAndParameters += "  Stationary velocity field kappa : " + QString::number(registration->GetStationaryVelocityFieldKappa()) + "\n";
    titleAndParameters += "  Use histogram matching? : " + QString::fromStdString(rpi::BooleanToString( registration->GetUseHistogramMatching())) + "\n";
    titleAndParameters += "  Terms in BCH expansion : " + QString::number(registration->GetNumberOfTermsBCHExpansion()) + "\n";
    titleAndParameters += "  Threshold stop values : " + QString::fromStdString(rpi::VectorToString<float>( registration->GetStopThreshold())) + "\n";
    titleAndParameters += "  Spatial smoothing standard deviation : " + QString::number(registration->GetSpatialDerivativeStandardDeviation()) + "\n";
    titleAndParameters += "  Step size for Hessian-norm constraint : " + QString::number(registration->GetAlternateProjectionStepSize()) + "\n";
    titleAndParameters += "  DTI standard deviation : " + QString::number(registration->GetHessianProjectionTensorStandardDeviation()) + "\n";

    switch( registration->GetNoiseEstimatorType() )
    {
    case 0:
        titleAndParameters += "  Noise estimator type : LOCAL\n";
        break;
    case 1:
        titleAndParameters += "  Noise estimator type : REGIONAL\n";
        break;
    case 2:
        titleAndParameters += "  Noise estimator type : GLOBAL\n";
        break;
    default:
        titleAndParameters += "  Noise estimator type : unknown\n";
    }

    titleAndParameters += "  Noise estimator standard deviation : " + QString::number(registration->GetNoiseEstimatorStandardDeviation()) + "\n";
    titleAndParameters += "  Use Levenberg-Marquardt method? : " + QString::fromStdString(rpi::BooleanToString( registration->GetNoiseEstimatorLM())) + "\n";
    titleAndParameters += "  Noise estimator epsilon : " + QString::number(registration->GetNoiseEstimatorEpsilon()) + "\n";

    return titleAndParameters;
}

bool itkProcessRegistrationILogDemons::writeTransform(const QString& file)
{
    qDebug()<<"itkProcessRegistrationILogDemons::writeTransform";
    typedef float PixelType;
    typedef float TransformScalarType;
    typedef double MaskPixelType;
    typedef itk::Image< PixelType, 3 > RegImageType;
    //normaly should use long switch cases, but here we know we work with float3 data.
    if (rpi::IncompressibleLogDemons< RegImageType, RegImageType, TransformScalarType, MaskPixelType > * registration =
            static_cast<rpi::IncompressibleLogDemons< RegImageType, RegImageType, TransformScalarType, MaskPixelType > *>(d->registrationMethod))
    {
        qDebug()<<"TRY";
        try{

            rpi::writeDisplacementFieldTransformation<TransformScalarType, RegImageType::ImageDimension>(
                        registration->GetTransformation(),
                        file.toStdString());
        }
        catch (std::exception)
        {
            return false;
        }
        return true;
    }
    else
    {
        return false;
    }
}

// /////////////////////////////////////////////////////////////////
// Process parameters
// /////////////////////////////////////////////////////////////////
void itkProcessRegistrationILogDemons::setNumberOfIterations(std::vector<unsigned int> iterations)
{
    d->iterations = iterations;
}
void itkProcessRegistrationILogDemons::setMinIterations(int minIterations)
{
    d->minIterations = minIterations ;
}
void itkProcessRegistrationILogDemons::setMaximumUpdateStepLength(float maximumUpdateStepLength)
{
    d->maximumUpdateStepLength =  maximumUpdateStepLength;
}
void itkProcessRegistrationILogDemons::setGradientType(unsigned int gradientType)
{
    d->gradientType = gradientType;
}
void itkProcessRegistrationILogDemons::setUpFieldSigma(float upFieldSigma)
{
    d->upFieldSigma = upFieldSigma;
}
void itkProcessRegistrationILogDemons::setUpFieldInc(unsigned int upFieldInc)
{
    d->upFieldInc = upFieldInc;
}
void itkProcessRegistrationILogDemons::setUpFieldKappa(float upFieldKappa)
{
    d->upFieldKappa = upFieldKappa;
}
void itkProcessRegistrationILogDemons::setVelFieldSigma(float velFieldSigma)
{
    d->velFieldSigma = velFieldSigma;
}
void itkProcessRegistrationILogDemons::setVelFieldInc(unsigned int velFieldInc)
{
    d->velFieldInc = velFieldInc;
}
void itkProcessRegistrationILogDemons::setVelFieldKappa(float velFieldKappa)
{
    d->velFieldKappa = velFieldKappa;
}
void itkProcessRegistrationILogDemons::setUseHistogramMatching(bool useHistogramMatching)
{
    d->useHistogramMatching = useHistogramMatching;
}
void itkProcessRegistrationILogDemons::setBCHExpansion(unsigned int BCHExpansion)
{
    d->BCHExpansion = BCHExpansion;
}
void itkProcessRegistrationILogDemons::setStop(std::vector<float> stop)
{
    d->stop = stop;
}
void itkProcessRegistrationILogDemons::setSpatialDerivativeSigma(float spatialDerivativeSigma)
{
    d->spatialDerivativeSigma = spatialDerivativeSigma;
}
void itkProcessRegistrationILogDemons::setStepSize(unsigned int stepSize)
{
    d->stepSize = stepSize;
}
void itkProcessRegistrationILogDemons::setDTIStandardDeviation(float DTIStandardDeviation)
{
    d->DTIStandardDeviation = DTIStandardDeviation;
}
void itkProcessRegistrationILogDemons::setNoiseEstimatorType(unsigned int noiseEstimatorType)
{
    d->noiseEstimatorType = noiseEstimatorType;
}
void itkProcessRegistrationILogDemons::setNoiseEstimatorSigma(float noiseEstimatorSigma)
{
    d->noiseEstimatorSigma = noiseEstimatorSigma;
}
void itkProcessRegistrationILogDemons::setNoiseEstimatorLM(bool noiseEstimatorLM)
{
    d->noiseEstimatorLM = noiseEstimatorLM;
}
void itkProcessRegistrationILogDemons::setNoiseEstimatorEpsilon(float noiseEstimatorEpsilon)
{
    d->noiseEstimatorEpsilon = noiseEstimatorEpsilon;
}

void itkProcessRegistrationILogDemons::setMask(dtkAbstractData *data)
{
    d->maskData = data;
}



// /////////////////////////////////////////////////////////////////
// Type instanciation
// /////////////////////////////////////////////////////////////////

dtkAbstractProcess *createitkProcessRegistrationILogDemons(void)
{
    return new itkProcessRegistrationILogDemons;
}

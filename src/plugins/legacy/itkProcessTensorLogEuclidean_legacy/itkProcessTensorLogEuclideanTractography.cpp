// /////////////////////////////////////////////////////////////////
// Generated by dtkPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "itkProcessTensorLogEuclideanTractography.h"

#include <dtkLog/dtkLog.h>

#include <dtkCore/dtkSmartPointer.h>
#include <dtkCore/dtkAbstractProcessFactory.h>
#include <medAbstractDataFactory.h>
#include <medAbstractData.h>

#include "itkQtSignalAdaptor.h"

#include "itkFiber.h"
#include "itkFiberTrackingImageFilter.h"
#include "itkLogTensorImageFilter.h"
#include "itkFiberImageToVtkPolyData.h"

#include "vtkFiberDataSet.h"

#include <vtkSmartPointer.h>

// /////////////////////////////////////////////////////////////////
// itkProcessTensorLogEuclideanTractographyPrivate
// /////////////////////////////////////////////////////////////////

class itkProcessTensorLogEuclideanTractographyPrivate
{
public:
    typedef float                                                          ScalarType;
    typedef itk::Tensor<ScalarType, 3>                                     TensorType;
    typedef itk::Image<TensorType, 3>                                      TensorImageType;
    typedef itk::LogTensorImageFilter<TensorImageType, TensorImageType>    LogFilterType;
    typedef itk::Fiber<ScalarType, 3>                                      FiberType;
    typedef itk::Image<FiberType, 3>                                       FiberImageType;
    typedef itk::FiberTrackingImageFilter<TensorImageType, FiberImageType> FiberTrackingFilterType;
    typedef itk::FiberImageToVtkPolyData<FiberImageType>                   FiberImageToVtkPolyDataType;

    dtkSmartPointer<medAbstractData>     output;
    vtkSmartPointer<vtkFiberDataSet>     dataset;
    FiberTrackingFilterType::Pointer     filter;
    LogFilterType::Pointer               loger;
    FiberImageToVtkPolyDataType::Pointer converter;
};

// /////////////////////////////////////////////////////////////////
// itkProcessTensorLogEuclideanTractography
// /////////////////////////////////////////////////////////////////

itkProcessTensorLogEuclideanTractography::itkProcessTensorLogEuclideanTractography(void) : medAbstractDiffusionProcess(), d(new itkProcessTensorLogEuclideanTractographyPrivate)
{
    d->output = medAbstractDataFactory::instance()->createSmartPointer ("medVtkFibersData");
    if (!d->output)
    {
        dtkWarn() << "Cannot create object of type medVtkFibersData";
    }

    d->dataset = vtkFiberDataSet::New();
    if (d->output)
        d->output->setData (d->dataset);

    d->filter = itkProcessTensorLogEuclideanTractographyPrivate::FiberTrackingFilterType::New();
    d->loger  = itkProcessTensorLogEuclideanTractographyPrivate::LogFilterType::New();
    d->converter = itkProcessTensorLogEuclideanTractographyPrivate::FiberImageToVtkPolyDataType::New();

    d->loger->ReleaseDataFlagOn();

    d->filter->SetLogTensorImage ( d->loger->GetOutput() );

    d->filter->SetIntegrationMethod (2);
    d->filter->SetUseTriLinearInterpolation (1);
    d->filter->SetTimeStep            (0.5);
    d->filter->SetOutputFiberSampling (1.0);
    d->filter->SetFAThreshold         (0.3);
    d->filter->SetFAThreshold2        (0.15);
    d->filter->SetSmoothness          (1.0);
    d->filter->SetSampling            (1);
    d->filter->SetTransformTensorWithImageDirection (1);
    d->filter->SetMinLength (10.0);
    d->filter->SetMaxLength (200.0);

    d->converter->SetInput ( d->filter->GetOutput() );

    itk::QtSignalAdaptor *adaptor1 = new itk::QtSignalAdaptor;
    d->filter->AddObserver (itk::ProgressEvent(), adaptor1->GetCommand());
    connect (adaptor1, SIGNAL(Signal (int)), this, SIGNAL (progressed (int)));

    itk::QtSignalAdaptor *adaptor2 = new itk::QtSignalAdaptor;
    d->converter->AddObserver (itk::ProgressEvent(), adaptor2->GetCommand());
    connect (adaptor2, SIGNAL(Signal (int)), this, SIGNAL (progressed (int)));
}

itkProcessTensorLogEuclideanTractography::~itkProcessTensorLogEuclideanTractography(void)
{
    delete d;
    d = 0;
}

bool itkProcessTensorLogEuclideanTractography::registered(void)
{
    return dtkAbstractProcessFactory::instance()->registerProcessType("itkProcessTensorLogEuclideanTractography", createItkProcessTensorLogEuclideanTractography);
}

QString itkProcessTensorLogEuclideanTractography::identifier(void) const
{
    return "itkProcessTensorLogEuclideanTractography";
}

QString itkProcessTensorLogEuclideanTractography::description(void) const
{
    return "itkProcessTensorLogEuclideanTractography";
}

void itkProcessTensorLogEuclideanTractography::setInputImage (medAbstractData* data)
{
    if (!data)
        return;

    typedef itkProcessTensorLogEuclideanTractographyPrivate::TensorImageType TensorImageType;

    if (data->identifier()=="itkDataTensorImageFloat3") {
        if (TensorImageType* tensors =
                static_cast<TensorImageType*>(data->data()))
        {
            d->loger->SetInput ( tensors );
            d->filter->SetInput ( tensors );
        }
    }
    else {
        qDebug() << "Input is not a tensor compatible object";
        return;
    }
}

medAbstractData *itkProcessTensorLogEuclideanTractography::output (void)
{
    return d->output;
}

int itkProcessTensorLogEuclideanTractography::update (void)
{
    try {
        d->filter->UpdateLargestPossibleRegion();
        d->converter->Update();
    }
    catch ( itk::ExceptionObject &e) {
        d->loger->AbortGenerateDataOff();
        d->loger->ResetPipeline();
        d->loger->GetOutput()->Initialize();

        d->filter->AbortGenerateDataOff();
        d->filter->ResetPipeline();
        d->filter->GetOutput()->Initialize();

        d->converter->AbortGenerateDataOff();
        d->converter->ResetPipeline();
        d->converter->GetOutput()->Initialize();

        qDebug() << e.GetDescription();
        return -1;
    }

    qDebug() << "Found: " << d->converter->GetOutput()->GetNumberOfLines();

    d->converter->GetOutput()->Update();
    d->dataset->Clear();
    d->dataset->SetFibers (d->converter->GetOutput());

    d->output->setMetaData("BundleList", QStringList());

    // this releases the memory, as we don't really need the output
    // of the tracking anymore.
    d->filter->GetOutput()->Initialize();

    return 0;
}

void itkProcessTensorLogEuclideanTractography::onCanceled (void)
{
    d->filter->AbortGenerateDataOn();
}

void itkProcessTensorLogEuclideanTractography::setParameter (double value, int channel)
{
    if (channel==IntegrationMethod) {
        d->filter->SetIntegrationMethod (static_cast<int>(value));
    }
    else if (channel==TriLinearInterpolation) {
        d->filter->SetUseTriLinearInterpolation (static_cast<int>(value));
    }
    else if (channel==TimeStep) {
        d->filter->SetTimeStep (value);
    }
    else if (channel==FiberSampling) {
        d->filter->SetOutputFiberSampling (value);
    }
    else if (channel==FAThreshold1) {
        d->filter->SetFAThreshold (value);
    }
    else if (channel==FAThreshold2) {
        d->filter->SetFAThreshold2 (value);
    }
    else if (channel==Smoothness) {
        d->filter->SetSmoothness (value);
    }
    else if (channel==Sampling) {
        d->filter->SetSampling (static_cast<int>(value));
    }
    else if (channel==TensorReorientation) {
        d->filter->SetTransformTensorWithImageDirection (static_cast<int>(value));
    }
    else if (channel==MinimumLength) {
        d->filter->SetMinLength (value);
    }
    else if (channel==MaximumLength) {
        d->filter->SetMaxLength (value);
    }
}

// /////////////////////////////////////////////////////////////////
// Type instanciation
// /////////////////////////////////////////////////////////////////

dtkAbstractProcess *createItkProcessTensorLogEuclideanTractography(void)
{
    return new itkProcessTensorLogEuclideanTractography;
}

// /////////////////////////////////////////////////////////////////
// Generated by medPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "undoRedoRegistration.h"

#include <dtkCore/dtkAbstractData.h>
#include <dtkCore/dtkAbstractDataFactory.h>
#include <dtkCore/dtkAbstractProcessFactory.h>
#include <hRegistrationFactory\hRegistrationFactory.h>
#include "itkImage.h"

// /////////////////////////////////////////////////////////////////
//
// /////////////////////////////////////////////////////////////////

//#include "itkImageRegistrationMethod.h"


/*#include "itkResampleImageFilter.h"
#include "itkCastImageFilter.h"


#include "time.h"

// Include specific RPI implementation of the registration method
#include <rpiUndoRedoRegistration.h>
#include <rpiCommonTools.hxx>*/

// /////////////////////////////////////////////////////////////////
// undoRedoRegistrationPrivate
// /////////////////////////////////////////////////////////////////

class undoRedoRegistrationPrivate
{
public:

    
    /*undoRedoRegistration * proc;
    template <class PixelType>
    int update(void);
    template <typename PixelType>
    bool writeTransform(const QString& file);
    
    void * registrationMethod;*/
    
};

// /////////////////////////////////////////////////////////////////
// undoRedoRegistration
// /////////////////////////////////////////////////////////////////

undoRedoRegistration::undoRedoRegistration(void) : itkProcessRegistration(), d(new undoRedoRegistrationPrivate)
{
    connect(hRegistrationFactory::instance(),SIGNAL(),this,SLOT());
    //this->output = dtkAbstractDataFactory::instance()->create ("itkDataImageFloat3");
    /*d->proc = this;
    d->registrationMethod = NULL;*/
}

undoRedoRegistration::~undoRedoRegistration(void)
{
    /*d->proc = NULL;

    typedef itk::Image< float, 3 >  RegImageType;
    
    if (d->registrationMethod)
        delete static_cast<rpi::UndoRedoRegistration< RegImageType, RegImageType,float > *>(d->registrationMethod);

    d->registrationMethod = NULL;
    
    delete d;
    d = 0;*/
}

bool undoRedoRegistration::registered(void)
{
    return dtkAbstractProcessFactory::instance()->registerProcessType("undoRedoRegistration",
                                                                 createUndoRedoRegistration);
}

QString undoRedoRegistration::description(void) const
{
    return "undoRedoRegistration";
}



// /////////////////////////////////////////////////////////////////
// Templated Version of update
// /////////////////////////////////////////////////////////////////


/*template <typename PixelType>
int undoRedoRegistrationPrivate::update(void)
{
    typedef itk::Image< PixelType, 3 >  FixedImageType;
    typedef itk::Image< PixelType, 3 >  MovingImageType;
    
    
    typename rpi::UndoRedoRegistration<FixedImageType,MovingImageType> * registration =
    new rpi::UndoRedoRegistration<FixedImageType,MovingImageType> ();
    
    registrationMethod = registration;
    
    registration->SetFixedImage((const FixedImageType*) proc->fixedImage().GetPointer());
    registration->SetMovingImage((const MovingImageType*) proc->movingImages()[0].GetPointer());
    
    
    // Run the registration
    time_t t1 = clock();
    try {
        registration->StartRegistration();
    }
    catch( std::exception & err )
    {
        qDebug() << "ExceptionObject caught ! (startRegistration)" << err.what();
        return 1;
    }
    
    time_t t2 = clock();
    
    qDebug() << "Elasped time: " << (double)(t2-t1)/(double)CLOCKS_PER_SEC;
    
    typedef itk::ResampleImageFilter< MovingImageType,MovingImageType >    ResampleFilterType;
    typename ResampleFilterType::Pointer resampler = ResampleFilterType::New();
    resampler->SetTransform(registration->GetTransformation());
    resampler->SetInput((const MovingImageType*)proc->movingImages()[0].GetPointer());
    resampler->SetSize( proc->fixedImage()->GetLargestPossibleRegion().GetSize() );
    resampler->SetOutputOrigin( proc->fixedImage()->GetOrigin() );
    resampler->SetOutputSpacing( proc->fixedImage()->GetSpacing() );
    resampler->SetOutputDirection( proc->fixedImage()->GetDirection() );
    resampler->SetDefaultPixelValue( 0 );
    
    
    try {
        resampler->Update();
    }
    catch (itk::ExceptionObject &e) {
        qDebug() << e.GetDescription();
        return 1;
    }
    
    itk::ImageBase<3>::Pointer result = resampler->GetOutput();
    result->DisconnectPipeline();
    
    if (proc->output())
        proc->output()->setData (result);
    return 0;
}*/

int undoRedoRegistration::update(itkProcessRegistration::ImageType imgType)
{
    /*if(fixedImage().IsNull() || movingImages()[0].IsNull())
        return 1;

    return d->update<float>();*/
    return 0;
}


/*template <typename PixelType>
bool undoRedoRegistrationPrivate::writeTransform(const QString& file)
{
    typedef double TransformScalarType;
    typedef itk::Image< PixelType, 3 > RegImageType;
    
    if (rpi::UndoRedoRegistration<RegImageType,RegImageType,TransformScalarType> * registration =
        static_cast<rpi::UndoRedoRegistration<RegImageType,RegImageType,TransformScalarType> *>(registrationMethod))
    {
        try{
            rpi::writeDisplacementFieldTransformation<TransformScalarType, 3>(registration->GetTransformation(),
                                                                              file.toStdString());
        }
        catch (std::exception)
        {
            return false;
        }
        return true;
    }
    else
    {
        return false;
    }
    
    return false;
}*/

bool undoRedoRegistration::writeTransform(const QString& file)
{
    /*if(d->registrationMethod == NULL)
        return 1;
    
    return d->writeTransform<float>(file);*/
    return false;
}

void undoRedoRegistration::undo(){
    itk::ImageRegistrationFactory<RegImageType>::Pointer m_factory = hRegistrationFactory::instance()->getItkRegistrationFactory<RegImageType>();
    m_factory->Undo();
    m_factory->Update();
    itk::ImageBase<3>::Pointer result = m_factory->GetOutput();
    if (this->output())
        this->output()->setData (result);
    
}
    
void undoRedoRegistration::redo(){
    itk::ImageRegistrationFactory<RegImageType>::Pointer m_factory = hRegistrationFactory::instance()->getItkRegistrationFactory<RegImageType>();
    m_factory->Redo();
    m_factory->Update();
    itk::ImageBase<3>::Pointer result = m_factory->GetOutput();
    if (this->output())
        this->output()->setData (result);
}

void undoRedoRegistration::setInput(dtkAbstractData *data, int channel){
    itkProcessRegistration::setInput(data,channel);
    hRegistrationFactory * medRegFac = hRegistrationFactory::instance();
    typedef itk::Image< float, 3 > RegImageType;
    itk::ImageRegistrationFactory<RegImageType>::Pointer factory = itk::ImageRegistrationFactory<RegImageType>::New(); 
    medRegFac->setItkRegistrationFactory<RegImageType>(factory);
    if (channel==0)
        medRegFac->getItkRegistrationFactory<RegImageType>()->SetFixedImage((RegImageType*)this->fixedImage().GetPointer());
    else if (channel==1)
        medRegFac->getItkRegistrationFactory<RegImageType>()->SetMovingImage((RegImageType*)this->movingImages()[0].GetPointer());
    medRegFac->reset();
}

// /////////////////////////////////////////////////////////////////
// Type instanciation
// /////////////////////////////////////////////////////////////////

dtkAbstractProcess *createUndoRedoRegistration(void)
{
    return new undoRedoRegistration;
}
